# Introduction

Synchronous RPC library inspired by [tarpc](https://github.com/google/tarpc) designed to be
simple to use, extendable and synchronous.

# Example usage

First we define trait containing one or more methods that will be remotely called.
We add `duty::service` macro on top of it.

```rust
#[duty::service]
pub trait TtvCalc {
    fn ttv_calc(&self, from: u64, to: u64) -> Vec<f64>;
}
```

Then we implement the trait on our type of choice:
```rust
pub struct Calculator {
    pub factor: f64,
}

impl TtvCalc for Calculator {
    fn ttv_calc(&self, from: u64, to: u64) -> Vec<f64> {
        (from..to).map(|x| x as f64 * self.factor).collect()
    }
}
```

To create service implementing `TtvCalc` trait we create transport layer, instantiate our type
and use `handle_next_request()` method generated by `service` macro:
```rust
    let listener = TcpListener::bind("0.0.0.0")?;

    let calculator = Calculator { factor: 1.5 };

    for connection in listener.incoming() {
        let mut transport = Bincode::new(connection?);

        while let Ok(()) = calculator.handle_next_request(&mut transport) {}
    }
```

To call service implementing `TtvCalc` trait we use `TtvCalcClient` struct generated by
`service` macro:
```rust
let stream = TcpStream::connect("myserver")?;
let client = TtvCalcClient::new(Bincode::new(stream))?;
let sum = client.ttv_calc(0, 42)?;
```

See examples in `./duty/exmaples` for more examples.
